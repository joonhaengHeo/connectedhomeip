{{> header}}
package chip.devicecontroller;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;
import chip.clusterinfo.ClusterInfo;
import chip.clusterinfo.InteractionInfo;
import chip.clusterinfo.CommandParameterInfo;
import chip.clusterinfo.DelegatedClusterCallback;
import chip.clusterinfo.ClusterCommandCallback;
import chip.clusterinfo.CommandResponseInfo;
import chip.devicecontroller.ClusterReadMapping;
import chip.devicecontroller.ClusterWriteMapping;
import chip.devicecontroller.model.InvokeElement;

public class ClusterInfoMapping {
 public Map<String, ClusterInfo> getClusterMap() {
    Map<String, ClusterInfo> clusterMap = initializeClusterMap();
    Map<String, Map<String, InteractionInfo>> commandMap = getCommandMap();
    combineCommand(clusterMap, commandMap);
    Map<String, Map<String, InteractionInfo>> readAttributeMap = new ClusterReadMapping().getReadAttributeMap();
    combineCommand(clusterMap, readAttributeMap);
    Map<String, Map<String, InteractionInfo>> writeAttributeMap = new ClusterWriteMapping().getWriteAttributeMap();
    combineCommand(clusterMap, writeAttributeMap);
    return clusterMap;
 }

 public Map<String, ClusterInfo> initializeClusterMap() {
    Map<String, ClusterInfo> clusterMap = new HashMap<>();
    {{#zcl_clusters}}
      ClusterInfo {{asLowerCamelCase name}}ClusterInfo = new ClusterInfo(
      ClusterIDMapping.{{asUpperCamelCase name}}.ID, new HashMap<>());
//        (ptr, endpointId) -> new ChipClusters.{{asUpperCamelCase name}}Cluster(ptr, endpointId), new HashMap<>());
      clusterMap.put("{{asLowerCamelCase name}}", {{asLowerCamelCase name}}ClusterInfo);
    {{/zcl_clusters}}
    return clusterMap;
 }

 public void combineCommand(Map<String, ClusterInfo> destination, Map<String, Map<String, InteractionInfo>> source) {
    {{#zcl_clusters}}
      destination.get("{{asLowerCamelCase name}}").combineCommands(source.get("{{asLowerCamelCase name}}"));
    {{/zcl_clusters}}
 }

  public static abstract class DelegatedInvokeCallback implements InvokeCallback, DelegatedClusterCallback {
  private ClusterCommandCallback callback;

  @Override
  public void setCallbackDelegate(ClusterCommandCallback callback) {
    this.callback = callback;
  }

  @Override
  public void onResponse(InvokeElement invokeElement, long successCode) {
    byte[] tlv = invokeElement.getTlvByteArray();
    Object obj = parseTlv(tlv);

    Map<CommandResponseInfo, Object> responseValues = new LinkedHashMap<>();
    if (obj != null) {
      CommandResponseInfo valueKey = new CommandResponseInfo("value", "String");
      responseValues.put(valueKey, obj);
    }
    callback.onSuccess(responseValues);
  }

  public abstract Object parseTlv(byte[] tlv);

  @Override
  public void onError(Exception e) {
    callback.onFailure(e);
  }
}

 @SuppressWarnings("unchecked")
 public Map<String, Map<String, InteractionInfo>> getCommandMap() {
     Map<String, Map<String, InteractionInfo>> commandMap = new HashMap<>();
     {{#zcl_clusters}}
     Map<String, InteractionInfo> {{asLowerCamelCase name}}ClusterInteractionInfoMap = new LinkedHashMap<>();
      {{#zcl_commands}}
          {{#if (is_str_equal source 'client')}}
     Map<String, CommandParameterInfo> {{asLowerCamelCase ../name}}{{asLowerCamelCase name}}CommandParams = new LinkedHashMap<String, CommandParameterInfo>();
     {{! TODO: fill out parameter types }}
     {{#if hasArguments}}
     {{#zcl_command_arguments}}
     {{#if_is_struct type}}
     {{else}}
       CommandParameterInfo {{asLowerCamelCase ../../name}}{{asLowerCamelCase ../name}}{{asLowerCamelCase label}}CommandParameterInfo = new CommandParameterInfo("{{asLowerCamelCase label}}", {{asJavaType type null parent.parent.name removeGenericType=true clusterId=parent.parent.id}}.class, {{asJavaType type null parent.parent.name underlyingType=true clusterId=parent.parent.id}}.class);
       {{asLowerCamelCase ../../name}}{{asLowerCamelCase ../name}}CommandParams.put("{{asLowerCamelCase label}}",{{asLowerCamelCase ../../name}}{{asLowerCamelCase ../name}}{{asLowerCamelCase label}}CommandParameterInfo);
     {{#not_last}} {{/not_last}}
     {{/if_is_struct}}
     {{/zcl_command_arguments}}
     {{else}}
     {{/if}}
     {{#if hasSpecificResponse}}
       InteractionInfo {{asLowerCamelCase ../name}}{{asLowerCamelCase name}}InteractionInfo = new InteractionInfo(
         (deviceController, devicePtr, endpointId, callback, commandArguments) -> {
            InvokeElement element = InvokeElement.newInstance(endpointId, ClusterIDMapping.{{asUpperCamelCase ../name}}.ID, ClusterIDMapping.{{asUpperCamelCase ../name}}.Command.{{asUpperCamelCase name}}.getID(), new byte[0], null);
            deviceController.invoke((DelegatedInvokeCallback) callback, devicePtr, element, 0,
            {{#if mustUseTimedInvoke}}
              10000
            {{else}}
              0
            {{/if}});
         //(cluster, callback, commandArguments) -> {
         //  ((ChipClusters.{{asUpperCamelCase ../name}}Cluster) cluster)
         //  .{{asLowerCamelCase name}}((ChipClusters.{{asUpperCamelCase ../name}}Cluster.{{asUpperCamelCase responseName}}Callback) callback
         //  {{#zcl_command_arguments}}
         //  , ({{asJavaType type chipType parent.parent.name clusterId=parent.parent.id}})
         //  commandArguments.get("{{asLowerCamelCase label}}")
         //  {{/zcl_command_arguments}}
         //   {{! TODO: Allow timeout to be passed from client for this and timed write. }}
         //  {{#if mustUseTimedInvoke}}, 10000{{/if}}
         //  );
         },
         //() -> new Delegated{{asUpperCamelCase ../name}}Cluster{{asUpperCamelCase responseName}}Callback(),
         () -> new DelegatedInvokeCallback() {
          @Override
          public Object parseTlv(byte[] tlv) {
            return null;
          }
         },
           {{asLowerCamelCase ../name}}{{asLowerCamelCase name}}CommandParams
       );
     {{else}}
       InteractionInfo {{asLowerCamelCase ../name}}{{asLowerCamelCase name}}InteractionInfo = new InteractionInfo(
         (deviceController, devicePtr, endpointId, callback, commandArguments) -> {
          InvokeElement element = InvokeElement.newInstance(endpointId, ClusterIDMapping.{{asUpperCamelCase ../name}}.ID, ClusterIDMapping.{{asUpperCamelCase ../name}}.Command.{{asUpperCamelCase name}}.getID(), new byte[0], null);
          deviceController.invoke((DelegatedInvokeCallback) callback, devicePtr, element, 0,
          {{#if mustUseTimedInvoke}}
            10000
          {{else}}
            0
          {{/if}});
         //(cluster, callback, commandArguments) -> {
         //  ((ChipClusters.{{asUpperCamelCase ../name}}Cluster) cluster)
         //  .{{asLowerCamelCase name}}((DefaultClusterCallback) callback
         //  {{#zcl_command_arguments}}
         //  , ({{asJavaType type chipType parent.parent.name clusterId=parent.parent.id}})
         //  commandArguments.get("{{asLowerCamelCase label}}")
         //  {{/zcl_command_arguments}}
         //  {{! TODO: Allow timeout to be passed from client for this and timed write. }}
         //  {{#if mustUseTimedInvoke}}, 10000{{/if}}
         //  );
         },
         //() -> new DelegatedDefaultClusterCallback(),
         () -> new DelegatedInvokeCallback() {
          @Override
          public Object parseTlv(byte[] tlv) {
            return null;
          }
         },
           {{asLowerCamelCase ../name}}{{asLowerCamelCase name}}CommandParams
       );
     {{/if}}
       {{asLowerCamelCase ../name}}ClusterInteractionInfoMap.put("{{asLowerCamelCase name}}", {{asLowerCamelCase ../name}}{{asLowerCamelCase name}}InteractionInfo);
          {{/if}}
      {{/zcl_commands}}
     commandMap.put("{{asLowerCamelCase name}}", {{asLowerCamelCase name}}ClusterInteractionInfoMap);
     {{/zcl_clusters}}
     return commandMap;
  }

}
