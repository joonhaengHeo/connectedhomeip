{%- macro optional_map(variable) -%}
  {{variable}}_map
{%- endmacro -%}

{%- macro arrayclone_it(variable) -%}
  {{variable}}_it
{%- endmacro -%}

{%- macro encode_clone(variable, source, encodable, depth) -%}
  {%- if encodable.is_nullable -%}
    ({{variable}} != null ? {{encode_clone(variable, source, encodable.without_nullable(), depth + 1)}} : null)
  {%- elif encodable.is_optional -%}
    {{variable}}.map({{optional_map(variable)}} -> {{encode_clone(optional_map(variable), source, encodable.without_optional(), depth + 1)}})
  {%- elif encodable.is_list -%}
    arrayClone({{variable}}, {{arrayclone_it(variable)}} -> {{encode_clone(arrayclone_it(variable), source, encodable.without_list(), depth + 1)}})
  {%- elif encodable.is_struct -%}
    {{variable}}.clone()
  {%- elif encodable.is_octet_string -%}
    {{variable}}.clone()
  {%- else -%}
    {{variable}}
  {%- endif -%}
{%- endmacro -%}

{%- macro encode_value(source, encodable, depth) -%}
  {%- if encodable.is_nullable -%}
    @Nullable {{encode_value(source, encodable.without_nullable(), depth + 1)}}
  {%- elif encodable.is_optional -%}
    Optional<{{encode_value(source, encodable.without_optional(), depth + 1)}}>
  {%- elif encodable.is_list -%}
    ArrayList<{{encode_value(source, encodable.without_list(), depth + 1)}}>
  {%- elif encodable.is_struct -%}
    {%- set struct = encodable.get_underlying_struct() -%}
    ChipStructs.{{source.name}}Cluster{{struct.name}}
  {%- else -%}
    {{encodable.boxed_java_type}}
  {%- endif -%}
{%- endmacro -%}

/*
 *
 *    Copyright (c) 2023 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package chip.devicecontroller;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Optional;

public class ChipEventStructs {
{%- for cluster in clientClusters | sort(attribute='code') -%}
{%- set typeLookup = idl | createLookupContext(cluster) %}
{%- for event in cluster.events %}
{%- if event.fields %}
public static class {{cluster.name}}Cluster{{event.name}}Event implements Cloneable {
  {%- for field in event.fields %}
  {%- set encodable = field | asEncodable(typeLookup) %}
  public {{encode_value(cluster, encodable, 0)}} {{field.name}};
  {%- endfor %}
  public {{cluster.name}}Cluster{{event.name}}Event(
    {%- for field in event.fields %}
    {%- set encodable = field | asEncodable(typeLookup) %}
    {{encode_value(cluster, encodable, 0)}} {{field.name}}
    {%- if loop.index0 < loop.length - 1 -%}{{","}}{%- endif -%}
    {%- endfor %}
  ) {
    {%- for field in event.fields %}
    {%- set encodable = field | asEncodable(typeLookup) %}
    this.{{field.name}} = {{field.name}};
    {%- endfor %}
  }

  @Override
  public String toString() {
    StringBuilder output = new StringBuilder();
    output.append("{{cluster.name}}Cluster{{event.name}}Event {\n");
    {%- for field in event.fields %}
    {%- set encodable = field | asEncodable(typeLookup) %}
    output.append("\t{{field.name}}: ");
    {%- if encodable.is_list %}
    output.append({{field.name}});
    {%- elif encodable.is_octet_string %}
    {%- if encodable.is_optional %}
    output.append({{field.name}}.isPresent() ? Arrays.toString({{field.name}}.get()) : "");
    {%- else %}
    output.append(Arrays.toString({{field.name}}));
    {%- endif %}
    {%- else %}
    output.append({{field.name}});
    {%- endif %}
    output.append("\n");
    {%- endfor %}
    output.append("}\n");
    return output.toString();
  }

  @Override
  public {{cluster.name}}Cluster{{event.name}}Event clone() {
    {{cluster.name}}Cluster{{event.name}}Event ret;
    try {
      ret = ({{cluster.name}}Cluster{{event.name}}Event)super.clone();
    } catch (CloneNotSupportedException e) {
      return null;
    }

  {%- for field in event.fields %}
    {%- set encodable = field | asEncodable(typeLookup) %}
    ret.{{field.name}} = {{encode_clone(field.name, cluster, encodable, 0)}};
  {%- endfor %}
    return ret;
  }
}
{%- endif %}
{%- endfor %}
{%- endfor %}
  private interface ArrayCloneFunction<T> {
    T cloneFunction(T input) throws CloneNotSupportedException;
  }

  private static<T> ArrayList<T> arrayClone(ArrayList<T> inputArray, ArrayCloneFunction<T> func) {
    ArrayList<T> ret = new ArrayList<T>(inputArray.size());
    for (T it : inputArray) {
      try {
        ret.add(func.cloneFunction(it));
      } catch (CloneNotSupportedException e) {
        // Ignore
      }
    }
    return ret;
  }
}
